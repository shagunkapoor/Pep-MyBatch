import java.util.Arrays;

public class DP {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		int n = 43;
		// long start=System.currentTimeMillis();
		// System.out.println(fibonacci(n));
		// System.out.println(fibM(n,new int[n+1]));
		// System.out.println(fibT(n));
		// long end=System.currentTimeMillis();
		// System.out.println(end-start);

		// System.out.println(countBoardPathM(0, 10, new int[10+1])); //
		// qb_size=dest-src+1
		// System.out.println(countBoardPathT(0, 10));
		// System.out.println(count2DBoardPathT(2, 2));
		// int[][] arr = { { 1, 8, 0, 5, 3 }, { 2, 8, 5, 2, 2 }, { 3, 0, 4, 8, 7
		// }, { 0, 5, 0, 0, 1 }, { 6, 0, 9, 6, 2 } };
		// System.out.println(minCostPath(4, 4, arr));

		// Aug 08

		// int[][] gold = { { 2, 2, 5, 8, 2 }, { 5, 3, 0, 0, 4 }, { 3, 4, 6, 7,
		// 7 }, { 4, 1, 0, 0, 0 },
		// { 0, 8, 8, 5, 5 } };
		//
		// System.out.println(Goldmine(gold));
		// System.out.println(countPalindromicSubstring("abccbc"));

		// int[] jumps = { 4, 0, 5, 2, 0, 3, 1, 0, 2, 1, 0 };
		// System.out.println(minJumps(jumps));

		// int[] lis = { 10, 22, 9, 33, 21, 50, 41, 60, 40, 1 };
		// System.out.println(longestIncreasingSubseq(lis));

		// int[] lbs = { 10, 22, 9, 33, 21, 50, 41, 60, 40, 1 };
		// System.out.println(longestBitonicSubseq(lbs));

		// int[] coins = { 2, 3, 5, 6 };
		// System.out.println(coinChangePermutation(coins, 10));
		// System.out.println(coinChangeCombination(coins, 10));

		// Aug 10
		String s = "abccbc";
		int[] dims = { 10, 20, 30, 40, 50, 60 };
		// System.out.println(minCutPalindrome(s, 0, 5, new
		// int[s.length()][s.length()]));
		// System.out.println(matrixChainMultiplication(dims, 0, dims.length -
		// 1, new int[dims.length][dims.length]));
		// System.out.println(maxsubseq("abcabc"));

		// Aug 12
		// int egg = 2;
		// int floor = 100;
		// System.out.println(eggDrop(egg, floor, new int[egg + 1][floor + 1]));

		// int[][] arr = { { 1, 0, 1, 0, 1, 1 }, { 1, 0, 1, 0, 1, 1 }, { 1, 0,
		// 1, 1, 1, 1 }, { 0, 0, 1, 1, 1, 0 },
		// { 0, 1, 1, 1, 1, 0 }, { 0, 1, 1, 1, 1, 0 }, { 1, 1, 1, 0, 0, 1 } };
		// System.out.println(maxSquareOfOnes(arr));

		System.out.println(mpcT("abccbc"));
	}

	public static int fibonacci(int n) { // 2^n
		if (n == 0 || n == 1) {
			return n;
		}

		int fibnm1 = fibonacci(n - 1);
		int fibnm2 = fibonacci(n - 2);
		int fibn = fibnm1 + fibnm2;

		return fibn;

	}

	public static int fibM(int n, int[] qb) {
		if (n == 0 || n == 1) {
			return n;
		}
		if (qb[n] != 0) {
			return qb[n];
		}
		int fibnm1 = fibM(n - 1, qb);
		int fibnm2 = fibM(n - 2, qb);
		int fibn = fibnm1 + fibnm2;

		qb[n] = fibn;

		return fibn;
	}

	public static int fibT(int n) {
		int[] fib = new int[n + 1];

		fib[0] = 0;
		fib[1] = 1;

		for (int i = 2; i <= n; i++) {
			fib[i] = fib[i - 1] + fib[i - 2];
		}

		return fib[n];
	}

	public static int countBoardPathM(int src, int dest, int[] qb) {
		if (src == dest) {
			return 1;
		}

		int cbpstd = 0;
		if (qb[src] != 0) {
			return qb[src];
		}
		for (int dice = 1; dice <= 6; dice++) {
			int inter = src + dice;
			if (inter <= dest) {
				int cbpitd = countBoardPathM(inter, dest, qb);
				cbpstd += cbpitd;
			}
		}
		qb[src] = cbpstd;

		return cbpstd;
	}

	public static int countBoardPathT(int src, int dest) {

		int[] f = new int[dest + 1];
		f[dest] = 1;

		for (int i = f.length - 1; i >= 0; i--) {
			for (int dice = 1; dice <= 6; dice++) {
				if (i + dice <= dest) {
					f[i] = f[i] + f[i + dice];
				}
			}
		}
		return f[0];
	}

	public static int count2DBoardPathT(int dr, int dc) { // Maze Path
		int[][] f = new int[dr + 1][dc + 1];

		for (int r = dr; r >= 0; r--) {
			for (int c = dc; c >= 0; c--) {
				// if (r == dr && c == dc) {
				// f[r][c] = 1;
				// } else if (r == dr) {
				// f[r][c] += f[r][c + 1];
				// } else if (c == dc) {
				// f[r][c] += f[r + 1][c];
				// } else {
				// f[r][c] += f[r + 1][c] + f[r][c + 1];
				// }
				// }
				// }
				// return f[0][0];
				//
				// }
				// OR

				f[dr][dc] = 1;
				if (r == dr || c == dc) {
					f[r][c] = 1;
				} else {
					f[r][c] += f[r + 1][c] + f[r][c + 1];
				}
			}
		}
		return f[0][0];

	}

	public static int minCostPath(int dr, int dc, int[][] arr) {

		int[][] f = new int[dr + 1][dc + 1];
		for (int r = dr; r >= 0; r--) {
			for (int c = dc; c >= 0; c--) {
				if (r == dr && c == dc) {
					f[r][c] = arr[r][c];
				} else if (r == dr) {
					f[r][c] = arr[r][c] + f[r][c + 1];
				} else if (c == dc) {
					f[r][c] = arr[r][c] + f[r + 1][c];
				} else {
					f[r][c] = arr[r][c] + Math.min(f[r][c + 1], f[r + 1][c]);
				}
			}
		}
		return f[0][0];
	}

	// Aug 08

	public static int Goldmine(int[][] gold) {
		int dc = gold[0].length - 1;
		int dr = gold.length - 1;
		int[][] f = new int[gold.length][gold[0].length];

		for (int r = 0; r < gold.length; r++) {
			f[r][dc] = gold[r][dc];
		}

		for (int c = dc - 1; c >= 0; c--) {
			for (int r = dr; r >= 0; r--) {
				if (r == 0) {
					f[r][c] = gold[r][c] + Math.max(f[r][c + 1], f[r + 1][c + 1]);
				} else if (r == dr) {
					f[r][c] = gold[r][c] + Math.max(f[r][c + 1], f[r - 1][c + 1]);
				} else {
					f[r][c] = gold[r][c] + Math.max(f[r][c + 1], Math.max(f[r - 1][c + 1], f[r + 1][c + 1]));
				}
			}
		}
		int max = f[0][0];
		for (int i = 0; i <= dr; i++) {
			if (max < f[i][0]) {
				max = f[i][0];
			}
		}
		return max;
	}

	public static int countPalindromicSubstring(String str) {
		boolean[][] arr = new boolean[str.length()][str.length()];
		int count = 0;
		// for(int gap=0;gap<=str.length()-1;gap++){ // 0-5
		// for(int sp=0;sp<=str.length()-1-gap;sp++){ //0 to len-gap
		// int ep=sp+gap;
		//
		// if(gap==0){ //len=1
		// arr[sp][ep]=true;
		// }else if(gap==1){ //len=2
		// arr[sp][ep]=str.charAt(sp)==str.charAt(ep);
		// }else{
		// arr[sp][ep]=str.charAt(sp)==str.charAt(ep) && arr[sp+1][ep-1];
		// }
		//
		// if(arr[sp][ep]==true){
		// count++;
		// }
		// }
		// }
		// return count;
		// }

		// OR
		for (int len = 1; len <= str.length(); len++) {
			for (int sp = 0; sp <= str.length() - len; sp++) {
				int ep = sp + len - 1;

				if (len == 1) {
					arr[sp][ep] = true;
				} else if (len == 2) {
					arr[sp][ep] = str.charAt(sp) == str.charAt(ep);
				} else {
					arr[sp][ep] = str.charAt(sp) == str.charAt(ep) && arr[sp + 1][ep - 1];
				}

				if (arr[sp][ep] == true) {
					count++;
				}
			}
		}
		return count;
	}

	public static Integer minJumps(int[] arr) {
		Integer[] minjumpcount = new Integer[arr.length];

		minjumpcount[arr.length - 1] = 0;

		for (int i = arr.length - 2; i >= 0; i--) {
			for (int j = i + 1; j <= i + arr[i] && j < arr.length; j++) {
				if (minjumpcount[j] == null) { // position on which it is
												// looking for min jump=null
					continue;
				} else {
					if (minjumpcount[i] == null) { // initialise the value with
													// its first nearest min
													// jump +1 for iits own jump
						minjumpcount[i] = minjumpcount[j] + 1;
					} else {
						minjumpcount[i] = Math.min(minjumpcount[i], minjumpcount[j] + 1);
					}
				}
			}
		}
		return minjumpcount[0];
	}

	// Aug 09

	public static int longestIncreasingSubseq(int[] arr) {   Kadane
		int[] countlis = new int[arr.length];

		countlis[0] = 1;

		for (int i = 1; i < arr.length; i++) {
			for (int j = i - 1; j >= 0; j--) {

				if (arr[i] > arr[j]) { // increasing
					int newcount = countlis[j] + 1;
					int oldcount = countlis[i];
					if (newcount > oldcount) {
						countlis[i] = newcount;
					}
				}
			}
		}
		int maxcount = countlis[0];
		for (int i = 1; i < arr.length; i++) {
			if (maxcount < countlis[i]) {
				maxcount = countlis[i];
			}
		}
		return maxcount;
	}

	public static int longestBitonicSubseq(int[] arr) {

		Integer[] lis = new Integer[arr.length];
		Integer[] lds = new Integer[arr.length];

		lis[0] = 1;
		lds[arr.length - 1] = 1;

		// lis
		for (int i = 1; i < arr.length; i++) {
			lis[i] = 1;
			for (int j = 0; j < i; j++) {
				if (arr[i] > arr[j])
					lis[i] = Math.max(lis[i], lis[j] + 1);
			}
		}
		// lds
		for (int i = arr.length - 1; i >= 0; i--) {
			lds[i] = 1;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[i] > arr[j]) {
					lds[i] = Math.max(lds[i], lds[j] + 1);
				}
			}
		}
		int lbscount = 0;
		for (int i = 0; i < arr.length; i++) {
			lbscount = Math.max(lis[i] + lds[i] - 1, lbscount);
		}

		return lbscount;
	}

	public static int coinChangePermutation(int[] coins, int amnt) {
		int[] coincount = new int[amnt + 1];

		coincount[0] = 1;
		for (int i = 1; i < coincount.length; i++) {
			for (int c = 0; c < coins.length; c++) {
				if ((i - coins[c]) >= 0) {
					coincount[i] += coincount[i - coins[c]];
				}
			}
		}
		return coincount[amnt];
	}

	public static int coinChangeCombination(int[] coins, int amnt) {
		int[] coincount = new int[amnt + 1];

		coincount[0] = 1;

		for (int c = 0; c < coins.length; c++) {
			for (int i = 1; i < coincount.length; i++) {
				if ((i - coins[c]) >= 0) {
					coincount[i] += coincount[i - coins[c]];
				}
			}
		}
		return coincount[amnt];
	}

	public static int minCutPalindrome(String str, int si, int ei, int[][] qb) {
		if (isPalindrome(str, si, ei)) {
			return 0;
		}
		if (qb[si][ei] != 0) {
			return qb[si][ei];
		}

		int totalcount = Integer.MAX_VALUE;
		for (int cutpnt = si; cutpnt < ei; cutpnt++) {
			int lres = minCutPalindrome(str, si, cutpnt, qb);
			int rres = minCutPalindrome(str, cutpnt + 1, ei, qb);
			totalcount = Math.min(totalcount, lres + rres + 1);
		}

		qb[si][ei] = totalcount;

		return totalcount;
	}

	public static boolean isPalindrome(String str, int si, int ei) {
		int left = si;
		int right = ei;
		while (left < right) {
			if (str.charAt(left) != str.charAt(right)) {
				return false;
			}
			left++;
			right--;
		}
		return true;
	}

	public static int matrixChainMultiplication(int[] dims, int si, int ei, int[][] qb) {
		if (ei - si == 1) {
			return 0;
		}

		if (qb[si][ei] != 0) {
			return qb[si][ei];
		}
		int totalcost = Integer.MAX_VALUE;
		for (int cp = si + 1; cp <= ei - 1; cp++) {
			int lcost = matrixChainMultiplication(dims, si, cp, qb);
			int rcost = matrixChainMultiplication(dims, cp, ei, qb);
			int realcost = dims[si] * dims[ei] * dims[cp];
			totalcost = Math.min(totalcost, lcost + rcost + realcost);
		}
		qb[si][ei] = totalcost;
		return totalcost;
	}

	public static int maxsubseq(String str) {
		int acount = 0, bcount = 0, ccount = 0;

		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == 'a') {
				acount = 1 + 2 * (acount);
			} else if (str.charAt(i) == 'b') {
				bcount = acount + 2 * (bcount);
			} else if (str.charAt(i) == 'c') {
				ccount = bcount + 2 * (ccount);
			}
		}
		return ccount;
	}

	// Aug 12

	public static int eggDrop(int eggs, int floors, int[][] qb) {
		if (eggs == 1 || eggs == 0) {
			return floors;
		}
		if (floors == 0) {
			return 0;
		}
		if (floors == 1) {
			return 1;
		}
		if (qb[eggs][floors] != 0) {
			return qb[eggs][floors];
		}

		int minTrial = Integer.MAX_VALUE;
		for (int k = 1; k <= floors; k++) {
			int mintrialeggbreak = eggDrop(eggs - 1, k - 1, qb);
			int mintrialeggsafe = eggDrop(eggs, floors - k, qb);
			int worstcase = Math.max(mintrialeggbreak, mintrialeggsafe);

			if (worstcase < minTrial) {
				minTrial = worstcase;
			}
		}
		qb[eggs][floors] = minTrial + 1;
		return minTrial + 1;
	}

	public static int maxSquareOfOnes(int[][] arr) {
		int[][] f = new int[arr.length][arr[0].length];

		for (int x = 0; x < arr[0].length; x++) {

			f[arr.length - 1][x] = arr[arr.length - 1][x];
		}
		for (int x = 0; x < arr.length; x++) {
			f[x][arr[0].length - 1] = arr[x][arr[0].length - 1];
		}
		for (int i = arr.length - 2; i >= 0; i--) {
			for (int j = arr[0].length - 2; j >= 0; j--) {
				if (arr[i][j] == 0) {
					f[i][j] = 0;
				} else {
					f[i][j] = Math.min(Math.min(f[i][j + 1], f[i + 1][j + 1]), f[i + 1][j]) + 1;
				}
			}
		}

		int max = f[0][0];
		for (int r = 0; r < arr.length; r++) {
			for (int c = 0; c < arr[0].length; c++) {
				if (f[r][c] > max) {
					max = f[r][c];
				}
			}
		}

		return max;
	}
	// public static int unboundedKnapSack(int[] wts,){
	//
	// }

	public static int mpcT(String str) {
		int[][] f = new int[str.length()][str.length()];

		for (int gap = 0; gap < f.length; gap++) {
			for (int sp = 0; sp <= f.length - 1 - gap; sp++) {
				int ep = sp + gap;

				if (gap == 0) {
					f[sp][ep] = 0; // Palindrome
				} else if (gap == 1) {
					f[sp][ep] = str.charAt(sp) == str.charAt(ep) ? 0 : 1;
				} else {
					if (str.charAt(sp) == str.charAt(ep)) {
						if (f[sp + 1][ep - 1] == 0)
							f[sp][ep] = 0; // Palindrome
					} else {
						for (int k = 1, j = gap; k <= gap && j >= 1; k++, j--) {
							f[sp][ep] = Math.min(f[sp][ep], f[sp][ep - k] + f[sp + j][ep] + 1);
						}
					}
				}
			}
		}

		return f[0][f.length - 1];
	}
}
