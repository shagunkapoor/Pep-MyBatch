package practice;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Amazonques {

	// public static void main(String[] args) {
	// Scanner scn = new Scanner(System.in);
	//
	// PriorityQueue pq = new PriorityQueue<>();
	// PriorityQueue temp = new PriorityQueue<>();
	//
	// int n = 10;
	// int q = 10;
	// for (int i = 0; i < q; i++) {
	// int m = scn.nextInt();
	// // pq.add(m);
	// temp.add(m);
	// pq.addAll(temp);
	// System.out.println(solve(m, 1, 10, pq));
	// }
	// }
	//
	// public static int solve(int m, int ll, int ul, PriorityQueue pq) {
	// int sum = ll;
	// while (pq.size() > 0) {
	// int rem = (int) pq.remove();
	//
	// if (pq.size() != 0) {
	// int top = (int) pq.peek();
	// sum += (top - 1) + (rem + 1);
	// }
	// }
	//
	// sum += ul;
	//
	// return sum;
	// }

	public static void main(String[] args) {
		int N = 6;

		int[][] tree = new int[N][N];
		int[] A = { 1, 5, 7, 8, 6, 10 };
		int[] X = { 6, 7, 2 };
		int[] L = { 1, 2, 6 };
		int[] u = { 1, 1, 2, 2, 3 };
		int[] v = { 2, 3, 4, 5, 6 };

		System.out.println(solve2(N, 3, tree, A, X, L, u, v));

	}

	public static class Node {
		int data;
		ArrayList<Node> children = new ArrayList<>();

		public Node(int data) {
			this.data = data;
		}
	}

	static Node root;

	public static int solve2(int N, int q, int[][] tree, int[] A, int[] X, int[] L, int[] u, int[] v) {
		root = new Node(A[0]);

		HashMap<Integer, ArrayList<Integer>> graph = new HashMap<>();

		for (int i = 0; i < N; i++) {

//			int val1 = A[u[i] - 1];
//			int val2 = A[v[i] - 1];
//
//			if (graph.containsKey(val1)) {
//				ArrayList<Integer> al1 = graph.get(val1);
//				al1.add(val2);
//				graph.put(val1, al1);
//			} else {
//				ArrayList<Integer> al2 = new ArrayList<>();
//				al2.add(val2);
//				graph.put(val1, al2);
//			}
//
//			if (graph.containsKey(val2)) {
//				ArrayList<Integer> al1 = graph.get(val2);
//				al1.add(val1);
//				graph.put(val2, al1);
//			} else {
//				ArrayList<Integer> al2 = new ArrayList<>();
//				al2.add(val1);
//				graph.put(val2, al2);
//			}

			 constructTree(A[u[i] - 1], A[v[i] - 1], u[i], v[i]);
		}
		

		int maxdep = maxdepth(root);

		for (int i = 0; i < q; i++) {
			int level = (L[i] % (maxdep + 1));

		}
		
		HashMap<Integer, ArrayList<Integer>> hlevels=new HashMap<>();
			addLevels(hlevels, root,0);
		
		return -1;
	}

	private static void constructTree(int val1, int val2, int u, int v) {
		Node n1 = new Node(val1);
		Node n2 = new Node(val2);
		n1.children.add(n2);

	}

	private static int maxdepth(Node root) {
		if (root == null) {
			return -1;
		}
		int level = 0;

		for (Node child : root.children) {
			int h = maxdepth(child);
			level = Math.max(level, h);
		}

		level += 1;
		return level;
	}

	private static void addLevels(HashMap<Integer, ArrayList<Integer>> hlevels, Node root, int l){
		if(root==null){
			return;
		}

		ArrayList<Integer> al=new ArrayList<>();
		if(hlevels.containsKey(l)){
			al=hlevels.get(l);
			al.add(root.data);
			hlevels.put(l, al);
		}else{
			al=new ArrayList<>();
		al.add(root.data);
		hlevels.put(l, al);
		}
		for(Node child:root.children){
			addLevels(hlevels,child,l+1);
		}
		
	}
}
